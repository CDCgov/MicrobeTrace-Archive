<!doctype html>
<html>
<head>
  <script>
  const electron = require('electron');
  const jetpack = require('fs-jetpack');
  const Papa = require('papaparse');
  const Lazy = require('lazy.js');
  const xss = require('xss');

  var data = {
    nodes: [],
    links: []
  };

  var defaultNode = function(){
    return {
      id: '',
      index: -1,
      padding: 0,
      selected: false,
      seq: '',
      cluster: 1,
      visible: true,
      degree: 0
    }
  };

  var instructions = {
    supplement: '',
    identifierColumn: 'id',
    sequenceColumn: 'seq',
    align: true,
    sourceColumn: 'source',
    targetColumn: 'target'
  };

  var index = 0;

  electron.ipcRenderer.on('deliver-instructions', (sender, i) => {
    Object.assign(instructions, i);
    electron.ipcRenderer.send('message', 'Parsing Link CSV...');
    var results = Papa.parse(xss(jetpack.read(instructions.file)), {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: true
    });

    data.links = results.data.map(link => {
      link.index = index++;
      link.orig = true;
      link.source = link[instructions.sourceColumn];
      link.target = link[instructions.targetColumn];
      link.cluster = 1;
      link.visible = true;
      return link;
    });
    electron.ipcRenderer.send('message', ' - Parsed ' + data.links.length + ' Links.');

    var llinks = Lazy(data.links);
    data.nodes = Lazy(
        llinks.pluck(instructions.sourceColumn).union(
        llinks.pluck(instructions.targetColumn))
      ).map((e, i) => Object.assign(defaultNode(), {
        id: e,
        index: i
      })).toArray();
    electron.ipcRenderer.send('message', ' - Inferred ' + data.nodes.length + ' distinct nodes.');
    if(instructions.supplement) matchCSV();
    electron.ipcRenderer.send('update-data', data);
    electron.remote.getCurrentWindow().close();
  });

  function matchCSV(){
    electron.ipcRenderer.send('message', 'Parsing Node CSV...');
    var k = 0, l = 0;

    let results = Papa.parse(xss(jetpack.read(instructions.supplement)), {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: true
    });
    electron.ipcRenderer.send('message', ' - Parsed ' + results.data.length + ' nodes from Supplement CSV.');

    electron.ipcRenderer.send('message', 'Matching to Inferred nodes...');
    results.data.forEach(node => {
      let match = data.nodes.find(n => n.id == node[instructions.identifierColumn]);
      if(match){
        Object.assign(match, node);
        k++;
      } else {
        data.nodes.push(Object.assign(defaultNode(), node, {index: index++}));
        l++;
      }
    });
    electron.ipcRenderer.send('message', ' - Matched ' + k + ' nodes.')
    electron.ipcRenderer.send('message', ' - Identified ' + l + ' additional singleton nodes.');
  }

  </script>
</head>
</html>
