<!doctype html>
<html>
<head>
  <script>
  const electron = require('electron');
  const bioseq   = require('bioseq');
  const fs       = require('fs');
  const tn93     = require('tn93');
  const Papa     = require('papaparse');
  const math     = require('bettermath');
  const hamming  = require('plain-hamming');
  const Lazy     = require('lazy.js');

  const hierarchy = ['distmat', 'link', 'node', 'fasta'];

  var data = {
    nodes: [],
    links: [],
    distance_matrix: {
      tn93: [],
      snps: []
    },
    nodeFields: ['id', 'padding', 'cluster', 'degree', 'seq', 'visible', 'selected', 'source'],
    linkFields: ['source', 'target', 'cluster', 'visible', 'distance', 'snps', 'origin']
  };

  var instructions = {
    align: false,
    files: [],
    reference: ''
  };

  var anySequences = false;

  electron.ipcRenderer.on('deliver-instructions', (sender, i) => {
    Object.assign(instructions, i);
    instructions.files.sort((a, b) => hierarchy.indexOf(a.type) - hierarchy.indexOf(b.type));
    instructions.files.forEach(file => {
      let filename = file.path.split(/[\\\/]/g).pop();

      if(file.type === 'fasta'){

        electron.ipcRenderer.send('message', `Parsing ${filename} as FASTA...`);
        anySequences = true;
        let n = 0, contents = fs.readFileSync(file.path, 'utf-8');
        let seqs = parseFASTA(contents);
        seqs.forEach(node => {
          node[file] = filename;
          n += addNode(node);
        });
        electron.ipcRenderer.send('message', ` - Parsed ${n} New, ${seqs.length} Total Nodes from FASTA.`);

      } else if(file.type === 'link'){

        electron.ipcRenderer.send('message', `Parsing ${filename} as Link CSV...`);
        let results = Papa.parse(fs.readFileSync(file.path, 'utf-8'), {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true
        });
        let n = 0;
        results.data.forEach(link => {
          n += addLink(Object.assign({
            source: link[file.field1],
            target: link[file.field2],
            origin: filename,
            visible: true
          }, link));
        });
        electron.ipcRenderer.send('message', ` - Parsed ${n} New, ${results.data.length} Total Links from Link CSV.`);

        data.linkFields = [...new Set([...data.linkFields, ...Object.keys(results.data[0])])];

        n = 0;
        let llinks = Lazy(results.data);
        let nodeIDs = llinks.pluck(file.field1).union(llinks.pluck(file.field2));
        let t = nodeIDs.size();
        nodeIDs.forEach(d => n += addNode({'id': d}));
        electron.ipcRenderer.send('message', ` - Parsed ${n} New, ${t} Total Nodes from Link CSV.`);

      } else if(file.type === 'node'){

        electron.ipcRenderer.send('message', `Parsing ${filename} as Node CSV...`);

        let results = Papa.parse(fs.readFileSync(file.path, 'utf-8'), {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true
        });
        let n = 0;
        results.data.forEach(node => {
          node.id = node[file.field1];
          if(file.field2 !== 'None') node.seq = node[file.field2];
          node.source = filename;
          n += addNode(node);
        });
        data.nodeFields = [...new Set([...data.nodeFields, ...Object.keys(results.data[0])])];
        if(data.nodeFields.includes('seq')) anySequences = true;

        electron.ipcRenderer.send('message', ` - Parsed ${n} New, ${results.data.length} Total Nodes from Node CSV.`);

      } else { //Distance Matrix

        electron.ipcRenderer.send('message', `Parsing ${filename} as Distance Matrix...`);

        let results = Papa.parse(fs.readFileSync(file.path, 'utf-8'), {
          dynamicTyping: true,
          skipEmptyLines: true
        });
        let nodeIDs = [];
        let nn = 0, nl = 0;
        results.data.forEach((row, i) => {
          if(i == 0){
            nodeIDs = row;
            nodeIDs.forEach((cell, k) => {
              if(k > 0){
                nn += addNode({
                  id: cell,
                  source: filename
                });
              }
            });
          } else {
            row.forEach((cell, j) => {
              if(j > i){
                nl += addLink({
                  source: nodeIDs[i],
                  target: nodeIDs[j],
                  distance: cell,
                  origin: filename
                });
              }
            });
          }
        });

        electron.ipcRenderer.send('message', ` - Parsed ${nn} New, ${results.data.length - 1} Total Nodes from Distance Matrix.`);
        electron.ipcRenderer.send('message', ` - Parsed ${nl} New, ${(Math.pow(results.data.length-1, 2) - results.data.length + 1)/2} Total Links from Distance Matrix.`);
      }
    });

    const allDashes = /^-*$/;

    //Alignment:
    if(anySequences && instructions.align){
      electron.ipcRenderer.send('message', 'Aligning Sequences...');
      data.nodes
        .filter(d => !allDashes.test(d.seq))
        .forEach(node => {
          let rst = bioseq.align(instructions.reference, node.seq, true, [1, -1], [-5, -1.7]);
          let fmt = bioseq.cigar2gaps(instructions.reference, node.seq, rst.position, rst.CIGAR);
          node.padding = rst.position;
          node.seq = fmt[1];
        });
    }

    if(anySequences){
      //Final step in alignment: left- and right- padding with hyphens
      let minPadding = math.min(data.nodes, 'padding');
      data.nodes.forEach(d => d.seq = "-".repeat(d.padding - minPadding) + d.seq);

      let maxLength = math.max(data.nodes.map(d => d.seq.length));
      data.nodes.forEach(d => d.seq = d.seq + "-".repeat(maxLength - d.seq.length));

      // Computing Distance Matrices:
      electron.ipcRenderer.send('message', 'Computing New Distance Matrices...');

      data.distance_matrix.tn93 = Array(data.nodes.length);
      data.distance_matrix.snps = Array(data.nodes.length);
      for(let i = 0; i < data.nodes.length; i++){
        data.distance_matrix.tn93[i] = Array(data.nodes.length);
        data.distance_matrix.snps[i] = Array(data.nodes.length);
        data.distance_matrix.tn93[i][i] = data.distance_matrix.snps[i][i] = 0;
        for(var j = 0; j < i; j++){
          let newLink = {
            'source': data.nodes[j].id,
            'target': data.nodes[i].id
          };
          if(!allDashes.test(data.nodes[j]['seq']) & !allDashes.test(data.nodes[i]['seq'])){
            newLink.distance = tn93(data.nodes[j]['seq'], data.nodes[i]['seq'], 'AVERAGE');
            newLink.snps = hamming(data.nodes[j]['seq'], data.nodes[i]['seq']);
            data.distance_matrix.tn93[i][j] = data.distance_matrix.tn93[j][i] = newLink.distance;
            data.distance_matrix.snps[i][j] = data.distance_matrix.snps[j][i] = newLink.snps;
          } else {
            data.distance_matrix.tn93[i][j] = data.distance_matrix.tn93[j][i] = null;
            data.distance_matrix.snps[i][j] = data.distance_matrix.snps[j][i] = null;
          }
          addLink(newLink);
        }
      }
    }

    function defaultNode(){
      return {
        id: '',
        padding: 0,
        selected: false,
        cluster: 1,
        visible: true,
        degree: 0,
        seq: '',
        source: ''
      }
    }

    function addNode(newNode){
      let oldNode = data.nodes.find(d => d.id === newNode.id);
      if(oldNode){
        Object.assign(oldNode, newNode);
        return 0;
      } else {
        data.nodes.push(Object.assign(defaultNode(), newNode));
        return 1;
      }
    }

    function defaultLink(){
      return {
        source: '',
        target: '',
        distance: 1,
        snps: Number.INFINITY,
        visible: false,
        cluster: 1,
        origin: 'Genetic Distance'
      }
    }

    function addLink(newLink){
      let oldLink = data.links.find(l => l.source === newLink.source & l.target === newLink.target);
      if(oldLink){
        Object.assign(oldLink, newLink);
        return 0;
      } else {
        data.links.push(Object.assign(defaultLink(), newLink));
        return 1;
      }
    }

    function parseFASTA(text){
      if(!text || text.length === 0) return []
      let seqs = [], currentSeq = {};
      text.split(/[\r\n]+/g).forEach((line, i) => {
        if(/^\s*$/.test(line)) return;
        if(line[0] == ">" || line[0] == ";"){
          if(i > 0) seqs.push(currentSeq);
          currentSeq = {
            id: line.slice(1),
            seq: ''
          };
        } else {
          currentSeq.seq += line;
        }
      });
      seqs.push(currentSeq);
      return seqs;
    }

    electron.ipcRenderer.send('update-data', data);
    electron.remote.getCurrentWindow().close();

  });

  </script>
</head>
</html>
