<!doctype html>
<html>
<head>
  <script>
  const electron = require('electron');
  const bioseq   = require('bioseq');
  const fs       = require('fs');
  const tn93     = require('tn93');
  const Papa     = require('papaparse');
  const math     = require('bettermath');
  const hamming  = require('plain-hamming');
  const Lazy     = require('lazy.js');

  const hierarchy = ['fasta', 'link', 'node', 'distmat'];

  var data = {
    nodes: [],
    links: [],
    distance_matrix: {
      tn93: [],
      snps: []
    },
    nodeFields: ['id', 'padding', 'selected'],
    linkFields: ['source', 'target', 'cluster', 'visible', 'distance', 'snps']
  };

  var instructions = {
    align: false,
    files: [],
    reference: ''
  };

  var anySequences = false;

  electron.ipcRenderer.on('deliver-instructions', (sender, i) => {
    Object.assign(instructions, i);
    instructions.files.sort((a, b) => hierarchy.indexOf(a.type) - hierarchy.indexOf(b.type));
    instructions.files.forEach(file => {
      let filename = file.path.split(/[\\\/]/g).pop();

      data.nodeFields.push(filename);
      data.linkFields.push(filename);

      if(file.type === 'fasta'){

        electron.ipcRenderer.send('message', `Parsing ${filename} as FASTA...`);
        anySequences = true;
        let n = 0, contents = fs.readFileSync(file.path, 'utf-8');
        let seqs = parseFASTA(contents);
        seqs.forEach(node => {
          node[filename] = true;
          n += addNode(node);
        });
        electron.ipcRenderer.send('message', ` - Parsed ${n} New, ${seqs.length} Total Nodes from FASTA.`);

      } else if(file.type === 'link'){

        electron.ipcRenderer.send('message', `Parsing ${filename} as Link CSV...`);
        let results = Papa.parse(fs.readFileSync(file.path, 'utf-8'), {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true
        });
        let n = 0;
        results.data.forEach(link => {
          link.source = link[file.field1];
          link.target = link[file.field2];
          link.cluster = 1;
          link.visible = true;
          link[filename] = true;
          n += addLink(link);
        });
        electron.ipcRenderer.send('message', ` - Parsed ${n} New, ${results.data.length} Total Links from Link CSV.`);

        data.linkFields = [...new Set([...data.linkFields, ...Object.keys(results.data[0]), filename])];

        n = 0;
        let llinks = Lazy(results.data);
        let nodeIDs = llinks.pluck(file.field1).union(llinks.pluck(file.field2));
        let t = nodeIDs.size();
        nodeIDs.forEach(d => n += addNode({'id': d}));
        electron.ipcRenderer.send('message', ` - Parsed ${n} New, ${t} Total Nodes from Link CSV.`);

      } else if(file.type === 'node'){

        electron.ipcRenderer.send('message', `Parsing ${filename} as Node CSV...`);

        let results = Papa.parse(fs.readFileSync(file.path, 'utf-8'), {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true
        });
        let n = 0;
        results.data.forEach(node => {
          node.id = node[file.field1];
          if(file.field2 !== 'None') node.seq = node[file.field2];
          node[filename] = true;
          n += addNode(node);
        });
        data.nodeFields = [...new Set([...data.nodeFields, ...Object.keys(results.data[0]), filename])];
        if(data.nodeFields.includes('seq')) anySequences = true;

        electron.ipcRenderer.send('message', ` - Parsed ${n} New, ${results.data.length} Total Nodes from Node CSV.`);

      } else { //Distance Matrix

        electron.ipcRenderer.send('message', `Parsing ${filename} as Distance Matrix...`);

        let results = Papa.parse(fs.readFileSync(file.path, 'utf-8'), {
          dynamicTyping: true,
          skipEmptyLines: true
        });
        let nodeIDs = [];
        let nn = 0, nl = 0;
        results.data.forEach((row, i) => {
          if(i == 0){
            nodeIDs = row;
            nodeIDs.forEach((cell, k) => {
              if(k > 0){
                let newNode = {id: cell};
                newNode[filename] = true;
                nn += addNode(newNode);
              }
            });
          } else {
            row.forEach((cell, j) => {
              if(j > i){
                let newLink = {
                  source: nodeIDs[i],
                  target: nodeIDs[j],
                  distance: cell
                };
                newLink[filename] = true;
                nl += addLink(newLink);
              }
            });
          }
        });

        electron.ipcRenderer.send('message', ` - Parsed ${nn} New, ${results.data.length - 1} Total Nodes from Distance Matrix.`);
        electron.ipcRenderer.send('message', ` - Parsed ${nl} New, ${(Math.pow(results.data.length-1, 2) - results.data.length + 1)/2} Total Links from Distance Matrix.`);

        data.nodeFields = [...new Set([...data.nodeFields, filename])];
        data.linkFields = [...new Set([...data.linkFields, filename])];

      }
    });

    //Alignment:
    if(anySequences && instructions.align){
      electron.ipcRenderer.send('message', 'Aligning Sequences...');
      data.nodes
        .filter(d => !(/^-*$/.test(d.seq)))
        .forEach(node => {
          let rst = bioseq.align(instructions.reference, node.seq, true, [1, -1], [-5, -1.7]);
          let fmt = bioseq.cigar2gaps(instructions.reference, node.seq, rst.position, rst.CIGAR);
          node.padding = rst.position;
          node.seq = fmt[1];
        });
    }

    if(anySequences){
      //Final step in alignment: left- and right- padding with hyphens
      let minPadding = math.min(data.nodes, 'padding');
      data.nodes.forEach(d => d.seq = "-".repeat(d.padding - minPadding) + d.seq);

      let maxLength = math.max(data.nodes.map(d => d.seq.length));
      data.nodes.forEach(d => d.seq = d.seq + "-".repeat(maxLength - d.seq.length));

      // Computing Distance Matrices:
      electron.ipcRenderer.send('message', 'Computing New Distance Matrices...');

      data.distance_matrix.tn93 = Array(data.nodes.length);
      data.distance_matrix.snps = Array(data.nodes.length);
      for(let i = 0; i < data.nodes.length; i++){
        data.distance_matrix.tn93[i] = Array(data.nodes.length);
        data.distance_matrix.snps[i] = Array(data.nodes.length);
        data.distance_matrix.tn93[i][i] = data.distance_matrix.snps[i][i] = 0;
        if(data.nodes[i].seq){
          if(data.nodes[i]['seq'] != '' & data.nodes[i]['seq'] != '-'.repeat(data.nodes[i]['seq'].length)){
            for(var j = 0; j < i; j++){
              let newLink = {
                'source': data.nodes[j].id,
                'target': data.nodes[i].id
              };
              if(data.nodes[j]['seq'] !== '' && data.nodes[j]['seq'] != '-'.repeat(data.nodes[j]['seq'].length)){
                newLink.distance = tn93(
                  data.nodes[j]['seq'],
                  data.nodes[i]['seq'],
                  'AVERAGE'
                );
                newLink.snps = hamming(data.nodes[j]['seq'], data.nodes[i]['seq']);
                data.distance_matrix.tn93[i][j] = data.distance_matrix.tn93[j][i] = newLink.distance;
                data.distance_matrix.snps[i][j] = data.distance_matrix.snps[j][i] = newLink.snps;
              }
              addLink(newLink);
            }
          }
        }
      }
    }

    function defaultNode(){
      return {
        id: '',
        padding: 0,
        selected: false,
        cluster: 1,
        visible: true,
        degree: 0,
        seq: ''
      }
    }

    function addNode(newNode){
      let oldNode = data.nodes.find(d => d.id == newNode.id);
      if(oldNode){
        Object.assign(oldNode, newNode);
        return 0;
      } else {
        data.nodes.push(Object.assign(defaultNode(), newNode));
        return 1;
      }
    }

    function defaultLink(){
      return {
        source: '',
        target: '',
        distance: 1,
        snps: Number.INFINITY,
        visible: true,
        cluster: 1
      }
    }

    function addLink(newLink){
      let oldLink = data.links.find(l => l.source == newLink.source & l.target == newLink.target);
      if(oldLink){
        Object.assign(oldLink, newLink);
        return 0;
      } else {
        data.links.push(Object.assign(defaultLink(), newLink));
        return 1;
      }
    }

    function parseFASTA(text){
      if(!text || text.length == 0) return []
      let seqs = [], currentSeq = {};
      text.split(/[\r\n]+/g).forEach((line, i) => {
        if(/^\s*$/.test(line)) return;
        if(line[0] == ">" || line[0] == ";"){
          if(i > 0) seqs.push(currentSeq);
          currentSeq = {
            id: line.slice(1),
            seq: ''
          };
        } else {
          currentSeq.seq += line;
        }
      });
      seqs.push(currentSeq);
      return seqs;
    }

    electron.ipcRenderer.send('update-data', data);
    electron.remote.getCurrentWindow().close();

  });

  </script>
</head>
</html>
