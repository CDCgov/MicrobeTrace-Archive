<!doctype html>
<html>
<head>
  <script>
  const electron = require('electron');
  const fasta    = require('fasta-parser');
  const jetpack  = require('fs-jetpack');
  const bioseq   = require('bioseq');
  const fs       = require('fs');
  const tn93     = require('tn93');
  const Baby     = require('babyparse');
  const math     = require('bettermath');

  var reference = electron.ipcRenderer.sendSync('get-component', 'HXB2.txt');

  var data = {
    nodes: [],
    links: []
  };

  var defaultNode = {
    padding: 0,
    seq: "",
    selected: false,
    index: -1
  }

  var instructions = {
    align: true,
    penalties: [-1.7, -5]
  };

  electron.ipcRenderer.on('deliver-instructions', (sender, i) => {
    Object.assign(instructions, i);
    parseFASTA();
  });

  function parseFASTA(){
    var message = 'Parsing FASTA file';
    if(instructions.align){
      message += ' and aligning sequences';
    }
    electron.ipcRenderer.send('message', message + '...');
    var filesize = fs.statSync(instructions.file).size;
    var covered = 0;
    var index = 0;
    var parser = fasta()
      .on('data', d => {
        var node = d.toString();
        covered += node.length;
        node = JSON.parse(node);
        node.padding = 0;
        if(instructions.align){
          var rst = bioseq.align(reference, node.seq, true, [1, -1], instructions.penalties);
          var fmt = bioseq.cigar2gaps(reference, node.seq, rst.position, rst.CIGAR);
          node.padding = rst.position;
          node.seq = fmt[1];
        }
        node.selected = false;
        node.index = index++;
        data.nodes.push(node);
        electron.ipcRenderer.send('tick', covered / filesize * 100);
      })
      .on('end', () => {
        var minPadding = math.min(data.nodes, 'padding');
        data.nodes.forEach(d => d.seq = "-".repeat(d.padding - minPadding) + d.seq);
        electron.ipcRenderer.send('tick', 100);
        electron.ipcRenderer.send('message', ' - Parsed ' + data.nodes.length + ' nodes.');
        if(instructions.supplement !== ''){
          matchCSV();
        }
        computeLinks();
      });
    parser.write(jetpack.read(instructions.file));
    parser.end();
  }

  function matchCSV(){
    electron.ipcRenderer.send('message', 'Parsing Node CSV...');
    var parsed = Baby.parseFiles(instructions.supplement, {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: true
    });
    csvNodes = parsed.data;
    electron.ipcRenderer.send('message', ' - Parsed ' + csvNodes.length + ' nodes from Supplement CSV.');

    var k = 0;
    electron.ipcRenderer.send('message', 'Matching to Inferred nodes...');
    csvNodes.forEach(node => {
      var match = data.nodes.find(n => n.id == node.id);
      if(match){
        Object.assign(match, node);
        k++;
      } else {
        data.nodes.push(Object.assign(node, defaultNode));
      }
    });
    electron.ipcRenderer.send('message', ' - Matched ' + k + ' nodes.');
  }

  function computeLinks(){
    electron.ipcRenderer.send('message', 'Computing Links...');
    var z = (data.nodes.length * (data.nodes.length - 1) / 2),
        k = 0,
        lastTick = 0,
        matrix = Array(data.nodes.length);
    for(var i = 0; i < data.nodes.length; i++){
      matrix[i] = math.repeat(0, data.nodes.length);
    }
    for(var i = 0; i < data.nodes.length; i++){
      for(var j = 0; j < i; j++){
        var dist = tn93(
          data.nodes[j]['seq'],
          data.nodes[i]['seq'],
          'AVERAGE'
        );
        data.links.push({
          index: k++,
          source: data.nodes[j].id,
          target: data.nodes[i].id,
          visible: (dist < 0.015),
          selected: false,
          distance: dist
        });
        matrix[i][j] = matrix[j][i] = dist;
        if(k / z * 100 > lastTick + 1){
          electron.ipcRenderer.send('tick', ++lastTick);
        }
      }
    }
    electron.ipcRenderer.send('message', ' - ' + z + ' links computed.');
    electron.ipcRenderer.send('update-distance-matrix', matrix);
    electron.ipcRenderer.send('update-data', data);
    electron.remote.getCurrentWindow().close();
  }

  </script>
</head>
</html>
