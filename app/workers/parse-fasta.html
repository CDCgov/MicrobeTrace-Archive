<!doctype html>
<html>
<head>
  <script>
  const electron = require('electron');
  const fasta    = require('fasta-parser');
  const jetpack  = require('fs-jetpack');
  const bioseq   = require('bioseq');
  const fs       = require('fs');
  const tn93     = require('tn93');
  const Papa     = require('papaparse');
  const math     = require('bettermath');
  const hamming  = require('plain-hamming');

  var reference = electron.ipcRenderer.sendSync('get-component', 'HXB2.txt');

  var data = {
    nodes: [],
    links: [],
    distance_matrix: []
  };

  var defaultNode = {
    id: '',
    index: -1,
    padding: 0,
    selected: false,
    seq: ''
  };

  var instructions = {
    align: true,
    penalties: [-5, -1.7]
  };

  var index = 0;

  electron.ipcRenderer.on('deliver-instructions', (sender, i) => {
    Object.assign(instructions, i);
    var message = 'Parsing FASTA file';
    if(instructions.align){
      message += ' and aligning sequences';
    }
    electron.ipcRenderer.send('message', message + '...');
    var filesize = fs.statSync(instructions.file).size;
    var covered = 0;
    var parser = fasta()
      .on('data', d => {
        var node = d.toString();
        covered += node.length;
        node = JSON.parse(node);
        node.padding = 0;
        if(instructions.align){
          var rst = bioseq.align(reference, node.seq, true, [1, -1], instructions.penalties);
          var fmt = bioseq.cigar2gaps(reference, node.seq, rst.position, rst.CIGAR);
          node.padding = rst.position;
          node.seq = fmt[1];
        }
        node.selected = false;
        node.index = index++;
        data.nodes.push(node);
        electron.ipcRenderer.send('tick', covered / filesize * 100);
      })
      .on('end', () => {
        var minPadding = math.min(data.nodes, 'padding');
        data.nodes.forEach(d => d.seq = "-".repeat(d.padding - minPadding) + d.seq);
        electron.ipcRenderer.send('tick', 100);
        electron.ipcRenderer.send('message', ' - Parsed ' + data.nodes.length + ' nodes.');
        if(instructions.supplement){
          matchCSV();
        }
        computeLinks();
      });
    parser.write(jetpack.read(instructions.file));
    parser.end();
  });

  function matchCSV(){
    electron.ipcRenderer.send('message', 'Parsing Node CSV...');
    var k = 0, l = 0;

    var results = Papa.parse(jetpack.read(instructions.supplement), {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: true
    });
    electron.ipcRenderer.send('message', ' - Parsed ' + results.data.length + ' nodes from Supplement CSV.');

    electron.ipcRenderer.send('message', 'Matching to Inferred nodes...');
    results.data.forEach(node => {
      var match = data.nodes.find(n => n.id == node[instructions.identifierColumn]);
      if(match){
        Object.assign(match, node);
        k++;
      } else {
        data.nodes.push(Object.assign({}, defaultNode, node, {index: index++}));
        l++;
      }
    });
    electron.ipcRenderer.send('message', ' - Matched ' + k + ' nodes.');
    electron.ipcRenderer.send('message', ' - Identified ' + l + ' singletons.');
  }

  function computeLinks(){
    electron.ipcRenderer.send('message', 'Computing Links...');
    var z = (data.nodes.length * (data.nodes.length - 1) / 2),
        k = 0,
        lastTick = 0;
    data.distance_matrix = Array(data.nodes.length);
    for(var i = 0; i < data.nodes.length; i++){
      data.distance_matrix[i] = math.repeat(0, data.nodes.length);
    }
    for(var i = 0; i < data.nodes.length; i++){
      for(var j = 0; j < i; j++){
        var dist = tn93(
          data.nodes[j]['seq'],
          data.nodes[i]['seq'],
          'AVERAGE'
        );
        var snps = hamming(data.nodes[j]['seq'], data.nodes[i]['seq']);
        data.links.push({
          'index': k++,
          'source': data.nodes[j].id,
          'target': data.nodes[i].id,
          'visible': (dist < 0.015),
          'selected': false,
          'distance': dist,
          'snps': snps
        });
        data.distance_matrix[i][j] = data.distance_matrix[j][i] = dist;
        if(k / z * 100 > lastTick + 1){
          electron.ipcRenderer.send('tick', ++lastTick);
        }
      }
    }
    electron.ipcRenderer.send('message', ' - ' + z + ' links computed.');
    electron.ipcRenderer.send('update-data', data);
    electron.remote.getCurrentWindow().close();
  }

  </script>
</head>
</html>
